#! /usr/bin/env python3


#
#        "number": number,
#        "name": name,
#        "project": project,
#        "timeEstimation": timeEstimation,
#        "wtype": wtype,
#        "DDL": DDL,
#        "remarks": remarks,
#        "timeUsed": "",
#        "afterThoughts": ""
#
#


import argparse
import os
import json
from datetime import datetime, date


sections = []
deprecatedSections = []
storedPath = "/home/ahacad/.distor/stored.json"
deprecatedPath = "/home/ahacad/.distor/deprecated.json"
extendedPath = "/home/ahacad/.distor/extended.json"
widthType = {"number": "short",
             "name": "long",
             "project": "norm",
             "timeEstimation": "short",
             "wtype": "short",
             "DDL": "norm",
             "remarks": "long",
             "timeUsed": "short",
             "afterThoughts": "long"
             }
widthLength = {"short": 4,
               "norm": 19,
               "long": 30}
colorTypes = {}


class colors:
    BLACK = "\033[0;30m"        # Black
    RED = "\033[0;31m"          # Red
    GREEN = "\033[0;32m"        # Green
    YELLOW = "\033[0;33m"       # Yellow
    BLUE = "\033[0;34m"         # Blue
    PURPLE = "\033[0;35m"       # Purple
    CYAN = "\033[0;36m"         # Cyan
    WHITE = "\033[0;37m"        # White
    RESET = "\033[0;0m"
    BOLD = "\033[;1m"
    REVERSE = "\033[;7m""]"


def loadSection():
    """load sections from the stored json file
    """
    with open(storedPath) as json_file:
        sections = json.load(json_file)
    global deprecatedSections
    with open(deprecatedPath) as json_file:
        deprecatedSections = json.load(json_file)
    global extendedSections
    with open(extendedPath) as json_file:
        extendedSections = json.load(json_file)
    return sections


def writeEntry():
    """store entries to the path
    """
    with open(storedPath, "w") as outfile:
        json.dump(sections, outfile, indent=4)
    with open(deprecatedPath, "w") as outfile:
        json.dump(deprecatedSections, outfile, indent=4)
    with open(extendedPath, "w") as outfile:
        json.dump(extendedSections, outfile, indent=4)


def addEntry(number, name, project, timeEstimation, wtype, DDL, remarks):
    """add an entry to the existing pool
    """
    sections.append({
        "number": number,
        "name": name,
        "project": project,
        "timeEstimation": timeEstimation,
        "wtype": wtype,
        "DDL": DDL,
        "remarks": remarks,
        "timeUsed": "",
        "afterThoughts": ""
        })
    return 0


def deprecateEntry(entryNumber):
    """remove the entry from the existing pool and add to the deprecated pool
    """
    for i in range(len(sections)):
        if sections[i]["number"] == entryNumber:
            deprecatedSections.append(sections.pop(i))
            return 1  # must return 1!


def modifyEntry(number, argument):
    """modify some specific entries
    """
    columnName, modification = argument.split("=")
    if (not columnName) or (not modification):
        raise ValueError("Invalid modification input")
    for section in sections:
        if section["number"] == number:
            section[columnName] = modification
            return 0


def printSectionHead(toPrintHeaders, toPrintColumns, printLineNumber=False,
                     printAfterwards=False, width=19):
    """print entries head"""
    for i in range(len(toPrintHeaders)):
        print(f"{toPrintHeaders[i]:^{widthLength[widthType[toPrintColumns[i]]]}}|", end="")
    print("\n", end="")
    

def printSection(toPrintHeaders, toPrintColumns, section,
                 printLineNumber=False, printAfterwards=False, width=19):
    """print one entry"""
    for item in toPrintColumns:
        print(f"{section[item]:^{widthLength[widthType[item]]}}|",
              end="")
    print("\n", end="")


def printSections(printLineNumber=False, printAfterwards=False, width=19):
    """print the entries in the existing pool, you can choose the way to display
    """
    toPrintColumns = ["name", "project", "timeEstimation", "wtype",
                      "DDL", "remarks"]
    toPrintHeaders = ["Name", "Project", "T/E", "Type", 
                      "DDL", "Remarks"]
    if printLineNumber:
        toPrintColumns.insert(0, "number")
        toPrintHeaders.insert(0, "Number")
    if printAfterwards:
        toPrintColumns.append("timeUsed")
        toPrintHeaders.append("T/U")
        toPrintColumns.append("afterThoughts")
        toPrintHeaders.append("Thoughts")
    printSectionHead(toPrintHeaders, toPrintColumns, printLineNumber, printAfterwards, width)
    for section in sections:
        printSection(toPrintHeaders, toPrintColumns,
                     section, printLineNumber, printAfterwards, width)
    return 0


class sortFuncs:
    def sortByDDL(x):
        """sort the sections by DDL"""
        return x['DDL']

    def sortByProject(x):
        """sort the sections by project"""
        return x["project"]

    def sortByNumber(x):
        """sort the sections by number"""
        return x["number"]


def sortEntry(choice="DDL"):
    """sort entry
    """
    global sections
    if choice == "DDL":
        sections.sort(key=sortFuncs.sortByDDL)
    elif choice == "project":
        sections.sort(key=sortFuncs.sortByProject)
    elif choice == "number":
        sections.sort(key=sortFuncs.sortByNumber)


def estimateTime():
    # how the time remained is calculated?
    """estimate whether you can make it before ddl
    """
    pass


def initializaition():
    """generate conifg file and folders"""
    if not os.path.exists(storedPath):
        pass


def cli():
    """the command line interface
    """
    parser = argparse.ArgumentParser(description="distor")
    parser.add_argument("-a", nargs=7, help="please add: Number, Name" +
                        " of the section, Project name, " +
                        "Time Estimation, DDL, and remarks (6 pa" +
                        "remeters)")
    parser.add_argument("-n", action="store_true", help="whether to " +
                        "section number or not")
    parser.add_argument("-d", nargs=1, help="input the number of the"
                        " section to be deleted")
    parser.add_argument("-c", action="store_true", help="automatically" +
                        " clean sections that have been finished")
    parser.add_argument("-w", nargs=1, help="width of print")
    parser.add_argument("-s", nargs=1, help="choose way of sort"
                        "support now: n - sort by number; "
                        "p - sort by project; "
                        "d - sort by DDL (default)")
    parser.add_argument("-m", nargs=2, help="modify entry, input two"
                        "elements: sectionNumber and modification in "
                        "the form of \"column=modification\"")
    args = parser.parse_args()
    return args


def testInput(number, name, project, timeEstimation, wtype, DDL, remarks):
    """ test the form of the input
    """
    pass


def calculateTimeRemained(ddl, sectionPerDay=24):
    """calculate time remained between today and the ddl
    default calculating by starting at morning today and
    end at night at the ddl day
    """
    today = date.today()
    ddl = datetime.strptime(ddl, "%Y-%m-%d").date()
    delta = (ddl - today).days
    timeRemained = (delta + 1) * sectionPerDay
    return timeRemained


def checkDDL():
    """check whether you can make it before ddl
    """
    


def autoClean():
    """automatically clean sections that have been finished
    """
    global deprecatedSections
    for section in sections:
        if section["timeUsed"] == section["timeEstimation"]:
            deprecatedSections.append(section)
            sections.remove(section)
        elif section["timeUsed"] > section["timeEstimation"]:
            extendedSections.append(section)
            sections.remove(section)
    return 0


def main():
    global sections
    # sections = loadSection()
    # addEntry(name, project, timeEstimation, DDL, remarks)
    #sections = {"sections": [{"Number": "00001", "Name": "testname1", 
    #"Project": "Mathe", "Time Estimation": "2", "DDL": "2020-06-12", "Remarks": "test"}]}
    args = cli()
    if os.path.exists(storedPath):
        sections = loadSection()
    if args.a:
        number = args.a[0]
        name = args.a[1]
        project = args.a[2]
        timeEstimation = args.a[3]
        wtype = args.a[4]
        DDL = args.a[5]
        remarks = args.a[6]
        testInput(number, name, project, timeEstimation, wtype, DDL, remarks)
        addEntry(number, name, project, timeEstimation, wtype, DDL, remarks)
    if args.d:
        if not deprecateEntry(args.d[0]):
            raise ValueError("Invaid delete input!")
    if args.c:
        autoClean()

    if args.m:
        modifyEntry(args.m[0], args.m[1])

    if not args.s:
        sortEntry()
    elif args.s[0] == "p":
        sortEntry(choice="project")
    elif args.s[0] == "n":
        sortEntry(choice="number")
    elif args.s[0] == "d":
        sortEntry()

    if args.w:
        width = args.w[0]
    else:
        width = 17
    if args.n:
        printSections(printLineNumber=True, printAfterwards=True, width=width)
    else:
        printSections(width=width)
    writeEntry()
    return 0


if __name__ == "__main__":
    main()



# WHAT NEXT
# learn to use argparse better, and build usages around it
#
#
# YET TO BUILD:
## LITTLE THINGS
# testInput (with python raise exceptions, help ensure input quality)
#
#
## MAIN FEATURES
### MORE COLORS
# use sty or the like to manage colors
### Initilization generated config
#       and header names to cater to different needs
###  CHECK whether you can make it before DDL
### GROUPING
# different coloring for grouped sections
# Divide one section into a series of small sections while being able to
#     represent their relationships
### Github actions
###  FILTER
### interactive software (like khal)
#
#
#
#
## POSSIBLE FEATURES
# More flexibly add columns, use pandas DataFrame or python lists to manage
#     columns, (allow infinite columnts)
#
# Print that automatically fit the length of string?
#
# modiry entries (I can just modify the json manually)
# database robustness: the mechanism to allow modify the basic sections
#    (maybe add more than the names later, so change them into more
#    flexible sections)
#
# better UI
#
## DONE
# x autoclean finished sections
# x delete entries and clear the whole database (with warnings)
# x more flexibility for column names





# techniques used:
# - json, for data process
# - format alignment and colored printing
# - sty, for colors
# - argParse, for cli
