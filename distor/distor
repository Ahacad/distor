#! /usr/bin/env python3


#
#        "number": number,
#        "name": name,
#        "project": project,
#        "timeEstimation": timeEstimation,
#        "wtype": wtype,
#        "DDL": DDL,
#        "remarks": remarks,
#        "timeUsed": "",
#        "afterThoughts": ""
#
#


import argparse
import os
import json
from datetime import datetime, date
from sty import fg
#from header import *


storedPath = "/home/ahacad/.distor/Dev/stored.json"
deprecatedPath = "/home/ahacad/.distor/Dev/deprecated.json"
extendedPath = "/home/ahacad/.distor/Dev/extended.json"
widthType = {"number": "medium",
             "name": "long",
             "project": "norm",
             "timeEstimation": "short",
             "wtype": "short",
             "DDL": "norm",
             "remarks": "long",
             "timeUsed": "short",
             "afterThoughts": "long"
             }
widthLength = {"short": 4,
               "medium": 6,
               "norm": 19,
               "long": 30}
colorTypes = {"number": "white",
              "name": "green",
              "project": "blue",
              "timeEstimation": "yellow",
              "wtype": "cyan",
              "DDL": "red",
              "remarks": "magenta",
              "timeUsed": "white",
              "afterThoughts": "white"
              }
colorsDic = {"red": fg.red,
             "green": fg.green,
             "yellow": fg.yellow,
             "blue": fg.blue,
             "magenta": fg.magenta,
             "cyan": fg.cyan,
             "white": fg.white}


class colors:
    BLACK = "\033[0;30m"        # Black
    RED = "\033[0;31m"          # Red
    GREEN = "\033[0;32m"        # Green
    YELLOW = "\033[0;33m"       # Yellow
    BLUE = "\033[0;34m"         # Blue
    PURPLE = "\033[0;35m"       # Purple
    CYAN = "\033[0;36m"         # Cyan
    WHITE = "\033[0;37m"        # White
    RESET = "\033[0;0m"
    BOLD = "\033[;1m"
    REVERSE = "\033[;7m""]"


def loadRows():
    """load sections from the stored json file
    """
    global rows
    with open(storedPath) as json_file:
        rows = json.load(json_file)
    global deprecatedRows 
    with open(deprecatedPath) as json_file:
        deprecatedRows = json.load(json_file)
    global extendedRows
    with open(extendedPath) as json_file:
        extendedRows = json.load(json_file)


def deleteColumn():
    """delete a whole column"""
    pass


def deleteRow():
    """delete a whole row"""
    pass


def deleteCell():
    """modify a single cell, changing it into empty string"""
    pass


def saveRows():
    """store entries to the path
    """
    with open(storedPath, "w") as outfile:
        json.dump(rows, outfile, indent=4)
    with open(deprecatedPath, "w") as outfile:
        json.dump(deprecatedRows, outfile, indent=4)
    with open(extendedPath, "w") as outfile:
        json.dump(extendedRows, outfile, indent=4)


#def addEntry(number, name, project, timeEstimation, wtype, DDL, remarks):
#    """add an entry to the existing pool
#    """
#    sections.append({
#        "number": number,
#        "name": name,
#        "project": project,
#        "timeEstimation": timeEstimation,
#        "wtype": wtype,
#        "DDL": DDL,
#        "remarks": remarks,
#        "timeUsed": "",
#        "afterThoughts": ""
#        })
#    return 0


#def deprecateEntry(entryNumber):
#    """remove the entry from the existing pool and add to the deprecated pool
#    """
#    for i in range(len(sections)):
#        if sections[i]["number"] == entryNumber:
#            deprecatedSections.append(sections.pop(i))
#            return 1  # must return 1!


#def modifyEntry(number, argument):
#    """modify some specific entries
#    """
#    columnName, modification = argument.split("=")
#    if (not columnName) or (not modification):
#        raise ValueError("Invalid modification input")
#    for section in sections:
#        if section["number"] == number:
#            section[columnName] = modification
#            return 0


#def printColor(item):
#    """print color by sty using the cusomized color dictionary"""
#    print(colorsDic[colorTypes[item]], end="")
#
#
#def colorReset():
#    """reset color by sty"""
#    print(fg.rs, end="")
#
#
#
#
#def printSectionHead(toPrintHeaders, toPrintColumns, printLineNumber=False,
#                     printAfterwards=False, width=19):
#    """print entries head"""
#    for i in range(len(toPrintHeaders)):
#        print(f"{toPrintHeaders[i]:^{widthLength[widthType[toPrintColumns[i]]]}}|", end="")
#    print("\n", end="")
#    
#
#def printSection(toPrintHeaders, toPrintColumns, section,
#                 printLineNumber=False, printAfterwards=False, width=19):
#    """print one entry"""
#    for item in toPrintColumns:
#        printColor(item)
#        print(f"{section[item]:^{widthLength[widthType[item]]}}",
#              end="")
#        colorReset()
#        print("|", end="")
#    print("\n", end="")
#
#
#def printSections(printLineNumber=False, printAfterwards=False, width=19):
#    """print the entries in the existing pool, you can choose the way to display
#    """
#    toPrintColumns = ["name", "project", "timeEstimation", "wtype",
#                      "DDL", "remarks"]
#    toPrintHeaders = ["Name", "Project", "T/E", "Type", 
#                      "DDL", "Remarks"]
#    if printLineNumber:
#        toPrintColumns.insert(0, "number")
#        toPrintHeaders.insert(0, "Number")
#    if printAfterwards:
#        toPrintColumns.append("timeUsed")
#        toPrintHeaders.append("T/U")
#        toPrintColumns.append("afterThoughts")
#        toPrintHeaders.append("Thoughts")
#    printSectionHead(toPrintHeaders, toPrintColumns, printLineNumber, printAfterwards, width)
#    for section in sections:
#        printSection(toPrintHeaders, toPrintColumns,
#                     section, printLineNumber, printAfterwards, width)
#    return 0


class sortFuncs:
    def sortByDDL(x):
        """sort the sections by DDL"""
        return x['DDL']

    def sortByProject(x):
        """sort the sections by project"""
        return x["project"]

    def sortByNumber(x):
        """sort the sections by number"""
        return x["number"]


def sortEntry(choice="DDL"):
    """sort entry
    """
    global sections
    if choice == "DDL":
        sections.sort(key=sortFuncs.sortByDDL)
    elif choice == "project":
        sections.sort(key=sortFuncs.sortByProject)
    elif choice == "number":
        sections.sort(key=sortFuncs.sortByNumber)


def estimateTime():
    # how the time remained is calculated?
    """estimate whether you can make it before ddl
    """
    pass


def initializaition():
    """generate conifg file and folders"""
    if not os.path.exists(storedPath):
        pass


def cli():
    """the command line interface
    """
    parser = argparse.ArgumentParser(description="distor")
    parser.add_argument("-a", nargs=7, help="please add: Number, Name" +
                        " of the section, Project name, " +
                        "Time Estimation, DDL, and remarks (6 pa" +
                        "remeters)")
    parser.add_argument("-n", action="store_true", help="whether to " +
                        "section number or not")
    parser.add_argument("-d", nargs=1, help="input the number of the"
                        " section to be deleted")
    parser.add_argument("-c", action="store_true", help="automatically" +
                        " clean sections that have been finished")
    parser.add_argument("-w", nargs=1, help="width of print")
    parser.add_argument("-s", nargs=1, help="choose way of sort"
                        "support now: n - sort by number; "
                        "p - sort by project; "
                        "d - sort by DDL (default)")
    parser.add_argument("-m", nargs=2, help="modify entry, input two"
                        "elements: sectionNumber and modification in "
                        "the form of \"column=modification\"")
    args = parser.parse_args()
    return args


def testInput(number, name, project, timeEstimation, wtype, DDL, remarks):
    """ test the form of the input
    """
    pass


def calculateTimeRemained(ddl, sectionPerDay=24):
    """calculate time remained between today and the ddl
    default calculating by starting at morning today and
    end at night at the ddl day
    """
    today = date.today()
    ddl = datetime.strptime(ddl, "%Y-%m-%d").date()
    delta = (ddl - today).days
    timeRemained = (delta + 1) * sectionPerDay
    return timeRemained


def checkDDL():
    """check whether you can make it before ddl
    """
    


def autoClean():
    """automatically clean sections that have been finished
    """
    global deprecatedSections
    for section in sections:
        if section["timeUsed"] == section["timeEstimation"]:
            deprecatedSections.append(section)
            sections.remove(section)
        elif section["timeUsed"] > section["timeEstimation"]:
            extendedSections.append(section)
            sections.remove(section)
    return 0


def main():
    global rows
    # sections = loadSection()
    # addEntry(name, project, timeEstimation, DDL, remarks)
    #sections = {"sections": [{"Number": "00001", "Name": "testname1", 
    #"Project": "Mathe", "Time Estimation": "2", "DDL": "2020-06-12", "Remarks": "test"}]}
    args = cli()
    if os.path.exists(storedPath):
        loadRows()
    saveRows()
    return 0
    #if args.a:
    #    number = args.a[0]
    #    name = args.a[1]
    #    project = args.a[2]
    #    timeEstimation = args.a[3]
    #    wtype = args.a[4]
    #    DDL = args.a[5]
    #    remarks = args.a[6]
    #    testInput(number, name, project, timeEstimation, wtype, DDL, remarks)
    #    addEntry(number, name, project, timeEstimation, wtype, DDL, remarks)
    #if args.d:
    #    if not deprecateEntry(args.d[0]):
    #        raise ValueError("Invaid delete input!")
    #if args.c:
    #    autoClean()

    #if args.m:
    #    modifyEntry(args.m[0], args.m[1])

    #if not args.s:
    #    sortEntry()
    #elif args.s[0] == "p":
    #    sortEntry(choice="project")
    #elif args.s[0] == "n":
    #    sortEntry(choice="number")
    #elif args.s[0] == "d":
    #    sortEntry()

    #if args.w:
    #    width = args.w[0]
    #else:
    #    width = 17
    #if args.n:
    #    printSections(printLineNumber=True, printAfterwards=True, width=width)
    #else:
    #    printSections(width=width)


if __name__ == "__main__":
    main()



# WHAT NEXT
# learn to use argparse better, and build usages around it
#
#
# YET TO BUILD:
## LITTLE THINGS
# testInput (with python raise exceptions, help ensure input quality)
#
#
## MAIN FEATURES
### REwrite data structures into more flexible excel-like columns and rows
### rewrite cli with click, substituting argparse
#      more flexible prints
###  CHECK whether you can make it before DDL
### GROUPING
# different coloring for grouped sections
# Divide one section into a series of small sections while being able to
#     represent their relationships
### Initilization generated config
#       and header names to cater to different needs
### Github actions
###  FILTER
### interactive software (like khal)
### BIGGER IDEA:
#       transform this into command line excel?
#
#
#
#
## POSSIBLE FEATURES
# More flexibly add columns, use pandas DataFrame or python lists to manage
#     columns, (allow infinite columnts)
#
# Print that automatically fit the length of string?
#
# modiry entries (I can just modify the json manually)
# database robustness: the mechanism to allow modify the basic sections
#    (maybe add more than the names later, so change them into more
#    flexible sections)
#
# better UI
#
## DONE
# MORE COLORS
#     use sty or the like to manage colors
# x autoclean finished sections
# x delete entries and clear the whole database (with warnings)
# x more flexibility for column names





# techniques used:
# - json, for data process
# - format alignment and colored printing
# - sty, for colors
# - argParse, for cli
